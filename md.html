<!DOCTYPE html>
<meta charset="utf-8">
<style>

.bubble {
  fill: brown;
  fill-opacity: 0.7;
  stroke: #000;
  stroke-width: 1.8px;
}

.county {
	fill: red;
	fill-opacity: 0.15;
	stroke: #000;
	stroke-width: 1.8px;
}

.border {
  fill: none;
  stroke: #000;
  stroke-width: 3.5px;
  stroke-linejoin: round;
  stroke-linecap: round;
}

.bubble :hover {
	fill: #7FFFD4;
	fill-opacity: 0.4;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script type="text/javascript" src="http://code.jquery.com/jquery-1.6.2.min.js"></script> 
<script type="text/javascript" src="jquery.tipsy.js"></script>
<link href="tipsy.css" rel="stylesheet" type="text/css" />
<script>

var width = 1260,
    height = 600;
	
/* NORMAL WAY*/
	
var scale = 8000,
	offset = [width / 2, height / 2];

// if projection not in Make	
var projection = d3.geo.mercator()
	.center([103, 38.7])
	.scale(scale)
	.rotate([-180, 0])
	.translate(offset);

var path = d3.geo.path()
    .projection(null);
	
var radius = d3.scale.sqrt()
    .domain([0, 1e6])
    .range([0, 15]);

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

//d3.json("md.json", function(error, us) {
d3.json("us.json", function(error, md) {
  if (error) return console.error(error);
  //console.log(md.objects.counties);
  
  // nation
  svg.append("path")
	  .datum(topojson.feature(md, md.objects.nation))
	  .attr("class", "border border--nation")
	  .attr("d", path);

  // counties
  svg.append("path")
      .datum(topojson.mesh(md))
	  .attr("class", "county")
      .attr("d", path);
	  
  /*  Would like to draw counties as individual paths...
  svg.append("g")
    //  .datum(topojson.mesh(md))
	  .attr("class", "county")
	.selectAll("path")
		.data(topojson.mesh(md))
		.enter()//.attr("d", path)
		.append("path")
			.attr("d", path)
		  .on("mouseover", function(d) {
			  d3.select(this).attr("fill-opacity", 0.5); })
		  .on("mouseout", function(d) {
			  d3.select(this).attr("fill-opacity", 0.2); });*/
	
  // states  
  svg.append("path")
	  .datum(topojson.mesh(md, md.objects.states, function(a, b) {
		  return a !== b; }))
	  .attr("class", "border border--state")
	  .attr("d", path);
  
  svg.append("g")	  
      .attr("class", "bubble")
    .selectAll("circle")
      .data(topojson.feature(md, md.objects.counties).features
        .sort(function(a, b) { return b.properties.population - a.properties.population; }))
    .enter().append("svg:circle")
      .attr("transform", function(d) { return "translate(" + path.centroid(d) + ")"; })
	  .attr("r", function(d) { return radius(d.properties.population) * 2; });

  // tipsy tooltip
  $('svg circle').tipsy({
	  gravity: 'width',
	  html: true,
	  title: function() {
		  var d = this.__data__, n = d.properties.name, p = d.properties.population;
		  return "<span style='color:#F9C396'>Pop: </span>"
				  + "<span style='color:white'>" + p + "</span>" +
				  " " + "<span style='color:#FFF3C3'>County: </span>" +
				  "<span style='color:eggwhite'>" + n + "</span>";
	  }
  });
		   
	// add rect around SVG to set bounds! 
	svg.append("rect")
		.attr("width", width)
		.attr("height", height)
		.style("stroke", "darkred")
		.style("stroke-width", 5.0)
		.style("fill", "none");
	  
});
	
/* DYNAMIC WAY 

To access location of map, scale, center, etc

*/

/*var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);
	
d3.json("md.json", function(error, md) {
	// if error with data print to console
	if (error) return conolse.error(error);
	
	// set up map within .json function
	var center = d3.geo.centroid(md),	// center of data
		scale = 500,
		offset = [width / 2, height / 2];
	
	// projection of map	
	var projection = d3.geo.mercator()
						.scale(scale)
						.center(center)
						.translate(offset);
						
	var path = d3.geo.path()
				.projection(projection);
				
	// use path to determine bounds of current map 
	// use to determine better values of scale and translation
	var bounds = path.bounds(md),
		hori = scale * width / (bounds[1][0] - bounds[0][0]),
		vert = scale * height / (bounds[1][1] - bounds[0][1]),
		scale = (hori < vert) ? hori : vert,	// tertiary! 
		offset = [width - (bounds[0][0] + bounds[1][0]) / 2, 
					height - (bounds[0][1] + bounds[1][1]) / 2];
	
	// new projection based on above parameters				
	projection = d3.geo.mercator()
					.center(center)
					.scale(scale)
					.translate(offset);
					
	path = path.projection(projection);
	
	// add rect around SVG to set bounds! 
	svg.append("rect")
		.attr("width", width)
		.attr("height", height)
		.style("stroke", "black")
		.style("fill", "none");
	
});*/
	
	
</script>