<!DOCTYPE html>
<meta charset="utf-8">
<style>

path {
  fill: none;
  stroke: #000;
  stroke-linejoin: round;
  stroke-linecap: round;
}

.bubble {
  fill: brown;
  fill-opacity: 0.7;
  stroke: #000;
  stroke-width: 1.8px;
}

.county {
	fill: red;
	fill-opacity: 0.2;
}

.state-border {
  fill: none;
  stroke: #000;
  stroke-width: 3.5px;
  stroke-linejoin: round;
  stroke-linecap: round;
}

/*.bubble :hover {
	fill: #000;
	fill-opacity: 0.5;
}
*/
</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script>

var width = 1260,
    height = 600;
	
/* NORMAL WAY*/
	
var scale = 8000,
	offset = [width / 2, height / 2];

// if projection not in Make	
var projection = d3.geo.mercator()
	.center([103, 38.7])
	.scale(scale)
	.rotate([-180, 0])
	.translate(offset);

var path = d3.geo.path()
    .projection(null);
	
var radius = d3.scale.sqrt()
    .domain([0, 1e6])
    .range([0, 15]);

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

//d3.json("md.json", function(error, us) {
d3.json("us.json", function(error, md) {
  if (error) return console.error(error);
  //console.log(md);
  //console.log(md.objects);
  //console.log(md.objects.counties);

  svg.append("path")
      .datum(topojson.mesh(md))
	  .attr("class", "county")
      .attr("d", path);
	  
  svg.append("path")
	  .datum(topojson.mesh(md, md.objects.states, function(a, b) {
		  return a !== b; }))
	  .attr("class", "state-border state-border--state")
	  .attr("d", path);
	  
  svg.append("g")
      .attr("class", "bubble")
    .selectAll("circle")
      .data(topojson.feature(md, md.objects.counties).features
        .sort(function(a, b) { return b.properties.population - a.properties.population; }))
    .enter().append("circle")
      .attr("transform", function(d) { return "translate(" + path.centroid(d) + ")"; })
      //.attr("r", function(d) { return radius(d.properties.population); });
	  /*.attr("r", 5.0)
	  .on("mouseover", function(d) {
		  d3.select(this).attr("r", 10.0);
	  })
	  .on("mouseout", function(d) {
		  d3.select(this).attr("r", 5.0);
	  });*/
	  .attr("r", function(d) { return radius(d.properties.population); })
	  .on("mouseover", function(d) {
		  d3.select(this).attr("fill", "black"); })
	  .on("mouseout", function(d) {
		  d3.select(this).attr("fill", "brown");
	  });
	  
	// add rect around SVG to set bounds! 
	svg.append("rect")
		.attr("width", width)
		.attr("height", height)
		.style("stroke", "darkred")
		.style("fill", "none");
	  
});
	
/* DYNAMIC WAY */

/*var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);
	
d3.json("md.json", function(error, md) {
	// if error with data print to console
	if (error) return conolse.error(error);
	
	// set up map within .json function
	var center = d3.geo.centroid(md),	// center of data
		scale = 500,
		offset = [width / 2, height / 2];
	
	// projection of map	
	var projection = d3.geo.mercator()
						.scale(scale)
						.center(center)
						.translate(offset);
						
	var path = d3.geo.path()
				.projection(projection);
				
	// use path to determine bounds of current map 
	// use to determine better values of scale and translation
	var bounds = path.bounds(md),
		hori = scale * width / (bounds[1][0] - bounds[0][0]),
		vert = scale * height / (bounds[1][1] - bounds[0][1]),
		scale = (hori < vert) ? hori : vert,	// tertiary! 
		offset = [width - (bounds[0][0] + bounds[1][0]) / 2, 
					height - (bounds[0][1] + bounds[1][1]) / 2];
	
	// new projection based on above parameters				
	projection = d3.geo.mercator()
					.center(center)
					.scale(scale)
					.translate(offset);
					
	path = path.projection(projection);
	
	// add rect around SVG to set bounds! 
	svg.append("rect")
		.attr("width", width)
		.attr("height", height)
		.style("stroke", "black")
		.style("fill", "none");
	
});*/
	
	
</script>